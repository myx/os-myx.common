#!/bin/sh

##### !!! This script is universal for FreeBSD, Darwin, Ubuntu. !!! #####

if type Parallel >/dev/null 2>&1 ; then
	return 0
fi

##### simple POSIX “Parallel” xargs replacement #####
Parallel(){
	set +x
	local WORKERS=${ENV_PARALLEL_WORKER_COUNT:-4} verbose='+'
	# parse options
	while [ $# -gt 0 ]; do case "$1" in
		--workers=*)	WORKERS=${1#*=}; shift ;;
		--workers|-w)	WORKERS=$2; shift 2 ;;
        --workers-x2|--turbo|--twice-as-hard)
			WORKERS=$((WORKERS * 2)); shift ;;
        --workers-x3|--overclock)
			WORKERS=$((WORKERS * 3)); shift ;;
        --workers-x4|--beast-mode)
			WORKERS=$((WORKERS * 4)); shift ;;
		--verbose|-v)   verbose='-'; shift ;;
		--quiet|-q)   verbose='+'; shift ;;
		--|--eval) shift; break ;;
		*) break ;;
	esac done

	[ -n "$verbose" ] || [ -z "$MDSC_DETAIL" ] || verbose='-'

	local PARALLEL_CMD="$@"
	[ -n "$PARALLEL_CMD" ] || PARALLEL_CMD=eval

	# sanity‐check
	[ "$WORKERS" -gt 0 ] 2>/dev/null || {
		echo '⛔ ERROR: Parallel: --workers must be a positive integer' >&2
		return 1
	}


	# make a unique tempdir and cleanup on EXIT
	local TMPPARALLEL_DIR; TMPPARALLEL_DIR="$(mktemp -d "${TMPDIR:-/tmp}/parallel.$$.XXXXXX")"
	trap "rm -rf -- '$TMPPARALLEL_DIR'" EXIT

	# runtime state
	local ACTIVE=0
	local SLOT_PIDS=   # “slot:waiterPid” pairs, e.g. “1:1234 2:1235”

	local PARALLEL_LINE ready slotspec slot mainPid


	local FIFO_CRTL="$TMPPARALLEL_DIR/ready-ctrl.$$.fifo"
	local FIFO_MAIN="$TMPPARALLEL_DIR/ready-main.$$.fifo"
	mkfifo "$FIFO_CRTL"
	mkfifo "$FIFO_MAIN"
	exec 3<>"$FIFO_CRTL" 
	exec 4<>"$FIFO_MAIN" 
	rm -- "$FIFO_CRTL" "$FIFO_MAIN"

	while dd bs=256 count=1 <&3 >/dev/null 2>&1; do 
		if ! echo >&4; then
			break
		fi
	done 2>/dev/null &
	mainPid=$!

	[ "$verbose" = '+' ] || echo ">> Parallel: [$mainPid] start, limit: $WORKERS, command: $PARALLEL_CMD, temp: $TMPPARALLEL_DIR" >&2

	local ready slot

	# dispatch loop
	while IFS= read -r PARALLEL_LINE 2>/dev/null; do
		
		# throttle: wait for any slot to free if we’re at limit
		while [ "$ACTIVE" -ge "$WORKERS" ]; do

			# cross-platform poll via `ls -1d`
			for ready in $(ls -1fd "$TMPPARALLEL_DIR/$mainPid"-slot-ready.* 2>/dev/null || :); do
				[ -e "$ready" ] || continue
				slot="${ready#*-slot-ready.}"
				if waiter="$(printf '%s\n' $SLOT_PIDS | grep "^$slot:")"; then
					# wait $waiterPid, should immediately return, anti-zombie
					wait ${waiter##*:} 2>/dev/null || :
				fi
				rm -f -- "$ready"
				ACTIVE=$((ACTIVE - 1))
				# remove that slot from in-flight list
				SLOT_PIDS=$(printf '%s\n' $SLOT_PIDS | grep -v "^$slot:" | tr '\n' ' ')
			done

			[ "$ACTIVE" -ge "$WORKERS" ] || break

			# sleep intil running job(s) finished
			if ! dd bs=128 count=1 <&4 >/dev/null 2>&1; then
				break 2
			fi

		done

		# pick the lowest free slot
		for ready in $(seq 1 "$WORKERS"); do
			case " $SLOT_PIDS " in
				*" $ready:"*) ;;                # in use
				*) slot=$ready; break;;
			esac
		done


		# one-time waiter for this job+slot, captures main loop pid, job pid, and slot as constants
		{
			set -e
			eval " 
				[ '$verbose' = '+' ] || echo '>> Parallel: exec: [$slot] $PARALLEL_CMD $PARALLEL_LINE' >&2
				( $PARALLEL_CMD $PARALLEL_LINE ) || echo \"⛔ ERROR: exited with error status (\$?)\" >&2
				touch '$TMPPARALLEL_DIR/$mainPid-slot-ready.$slot' || :
				[ '$verbose' = '+' ] || echo '>> Parallel: done: [$slot]' >&2
			" 
			echo >&3 || :
		} </dev/null &

		# book-keep: <slotNumber>:<waiterPid>
		SLOT_PIDS="$slot:$! $SLOT_PIDS"
		ACTIVE=$((ACTIVE + 1))

	done

	[ "$verbose" = '+' ] || echo ">> Parallel: [$mainPid] all dispatched" >&2

	#echo "Parallel: all dispatched"
	exec 4>&- || :
	echo >&3 || :
	exec 3>&- || :
	pkill -P $mainPid 2>/dev/null || :
	kill $mainPid 2>/dev/null || :
	wait $mainPid 2>/dev/null || :
	wait || :

	[ "$verbose" = '+' ] || echo ">> Parallel: [$mainPid] done." >&2
}

case "$0" in
	*/myx.common/bin/lib/parallel.Common) 
		if [ -z "$1" ] || [ "$1" = '--help' ] ; then
			. "${MYXROOT:-/usr/local/share/myx.common}/help/lib/parallel.help.include" >&2
			exit 1
		fi
		set -e
		Parallel "$@"
	;;
esac
