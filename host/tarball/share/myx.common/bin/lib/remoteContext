#!/usr/bin/env sh

##### !!! This script is universal for FreeBSD, Darwin, Ubuntu. !!! #####

# type Unbuffer >/dev/null 2>&1 || \
#	. "${MYXROOT:-/usr/local/share/myx.common}/bin/lib/unbuffer"

RemoteContext(){
	while [ $# -gt 0 ]; do
		case "$1" in
			--intern-no-comment-cat-for-script)
				sed \
					-e 's/^[[:space:]]*//' \
					-e 's/[[:space:]]*$//' \
					-e 's/[[:space:]]*#.*$//' \
					-e '/^$/d' \
					-e 's/\t/    /g'
				return 0
			;;
			--intern-one-liner-cat-for-script)
  				sed \
					-e 's/^[[:space:]]*//' \
					-e 's/[[:space:]]#.*$//' \
					-e 's/[[:space:]]*$//' \
					-e 's/^#.*$//' \
					-e '/^$/d'  \
					-e 's/\t/    /g'\
				| sed -n \
					-e ':a' \
					-e 'N' \
					-e '$!ba' \
					-e 's/\\\n//g' \
					-e 's/[[:space:]]*$//' \
					-e 's/case\n/case /g' \
					-e 's/then\n/then /g' \
					-e 's/else\n/else /g' \
					-e 's/elif\n/elif /g' \
					-e 's/do\n/do /g' \
					-e 's/;\n/; /g' \
					-e 's/(\n/( /g' \
					-e 's/{\n/{ /g' \
					-e 's/\n/; /g' \
					-e 'p' 
				return 0
				sed -n \
					-e 's/^[[:space:]]*#.*$//' \
					-e 's/[[:space:]][[:space:]]*#.*$//' \
					-e '/^[[:space:]]*$/d' \
					-e ':a' -e 'N' -e '$!ba' \
					-e 's/\\\n//g' \
					-e 's/^[[:space:]]*//; s/[[:space:]]*$//' \
					-e 's/case\n/case /g' \
					-e 's/then\n/then /g' \
					-e 's/else\n/else /g' \
					-e 's/elif\n/elif /g' \
					-e 's/do\n/do /g' \
					-e 's/;\n/; /g' \
					-e 's/(\n/( /g' \
					-e 's/{\n/{ /g' \
					-e 's/\n/; /g' \
					-e 'p'
				return 0
			;;
			*) break ;;
		esac
	done

	local verbose='' interactive='' force='' clean='' requireBash=''

	while [ $# -gt 0 ]; do
		case "$1" in
			--verbose|-v) verbose="v$verbose" ; shift ;;
			--interactive|-i) interactive=i ; shift ;;
			--force|-f) force=f ; shift ;;
			--clean|-c) clean=c ; shift ;;
			--require-bash) requireBash=bash; shift ;;
			--|--*) break ;;
			-?)
				echo "Local: ⛔ ERROR: RemoteContext: Unknown option: $1" >&2
				RemoteContext --help-syntax
				exit 1
			;;
			-?*) # bundled single-char flags: -vfi, -cf, etc.
				local flags=${1#-} ; shift
				set -- $(echo "$flags" | sed 's/./-& /g') "$@"
			;;
			*) break ;;
		esac
	done

	# require at least one arg
	[ ! $# -eq 0 ] || {
		RemoteContext --help-syntax
		exit 1
	}

	set -e
	local includeTarballs='' includePaths='' includeScripts='' includeCommands=''

	while [ $# -gt 0 ]; do
	case "$1" in
		--insert-path)
			[ -n "$2" ] || { echo "Local: ⛔ ERROR: RemoteContext: $1 needs an argument" >&2; exit 1; }
			local pair=$2; shift 2

			# split local[:remote]
			local srcLocal=${pair%%:*}
			local subLocal=${pair#*:}
			# if no “:” then remotePath==pair; detect & clear
			[ "$subLocal" = "$srcLocal" ] && subLocal=''

			# make local absolute
			case "$srcLocal" in
				/*) local absLocal="$srcLocal" ;;
				*)  local absLocal="${PWD%/}/$srcLocal" ;;
			esac

			# sanity-check local exists
			if [ ! -e "$absLocal" ]; then
				echo "Local: ❌ ERROR: RemoteContext: local path not found: $absLocal" >&2
				[ -z "$force" ] || continue;
				exit 1
			fi

			# strip any leading slash to force relativity
			subLocal=${subLocal#/}

			# append to list (newline-separated)
			includePaths="${includePaths}${absLocal}:${subLocal}\n"
		;;

		--insert-tarball)
			[ -n "$2" ] || { echo "Local: ⛔ ERROR: RemoteContext: $1 needs a file path" >&2; exit 1; }
			local tarballPath=$2; shift 2

			# make absolute
			case "$tarballPath" in
				/*) local absFile="$tarballPath" ;;
				*)  local absFile="${PWD%/}/$tarballPath" ;;
			esac

			[ -f "$absFile" ] || {
				echo "Local: ❌ ERROR: RemoteContext: script file not found: $absFile" >&2
				[ -z "$force" ] || continue;
				exit 1
			}

			includeScripts="${includeTarballs}${absFile}\n"
		;;

		--insert-script)
			[ -n "$2" ] || { echo "Local: ⛔ ERROR: RemoteContext: $1 needs a file path" >&2; exit 1; }
			local scriptPath=$2; shift 2

			# make absolute
			case "$scriptPath" in
				/*) local absFile="$scriptPath" ;;
				*)  local absFile="${PWD%/}/$scriptPath" ;;
			esac

			[ -f "$absFile" ] || {
				echo "Local: ❌ ERROR: RemoteContext: script file not found: $absFile" >&2
				[ -z "$force" ] || continue;
				exit 1
			}

			includeScripts="${includeScripts}${absFile}\n"
		;;

		--insert-command)
			[ -n "$2" ] || { echo "Local: ⛔ RemoteContext: $1 needs a string" >&2; exit 1; }
			local cmd=$2; shift 2
			includeCommands="${includeCommands}${cmd}\n"
		;;

		--myx.common)
			shift
			local srcBase="${MYXROOT:-/usr/local/share/myx.common}" ; srcBase="${srcBase%/share/myx.common}"
			#	--insert-path "$srcBase/:bin/myx.common" \
			#	--insert-path "$srcBase/:share/myx.common/" \
			set -- \
				--insert-path "$srcBase/:." \
				--insert-script "$srcBase/share/myx.common/include/remote/myx.common-init-mixin.base.sh.include" \
				"$@"
		;;

		--help|--help-syntax)
			. "${MYXROOT:-/usr/local/share/myx.common}/include/help/lib/remoteContext.help.include" >&2
			return 0
		;;

		-*)
			echo "Local: ⛔ ERROR: RemoteContext: Unknown option: $1" >&2
			RemoteContext --help-syntax
			exit 1
		;;

		*) 
			break
		;;
	esac
	done

	if [ -z "$force" ] && [[ -t 1 ]]; then
		echo "Local: ⛔ ERROR: RemoteContext: This script generates a payload that must be piped into a remote shell. Use --force to proceed or add a pipe." >&2
		exit 1
	fi

	[ -z "$interactive" ] || [ -z "$clean" ] || {
		echo "Local: ⛔ ERROR: RemoteContext: Can't use --interactive && --clean simultaneously." >&2
		exit 1
	}

	local templateRoot="${MYXROOT:-/usr/local/share/myx.common}/include/remote/"

	if [ -n "$interactive" ] || [ -n "$requireBash" ] ; then
		[ -z "$interactive" ] || echo '[ -t 0 ] && stty -echo'
		{
			cat "$templateRoot/step0-check-start-shell.sh.include"
		} | RemoteContext --intern-one-liner-cat-for-script
		awk 'BEGIN { for(i=1;i<=8192;i++)printf"#\010"; }' # purge shell's buffer
	fi

	if [ -n "$interactive" ] ; then
		echo 'stty -echo'
		echo 'PS1="Remote: ⌛︎ Interactive wrapper set."'
		printf '{ %s ; }\n' "$(
			{
				cat "$templateRoot/step1-interactive-prefix.sh.include"
				cat "$templateRoot/step2-interactive-prefix.sh.include"
			} | RemoteContext --intern-one-liner-cat-for-script
		)"
	fi

	[ -z "${verbose:1}" ] || {
		echo 'set -x'
	}
	[ -z "${verbose:1}" ] || {
		echo 'export MDSC_DETAIL=true'
		local MDSC_DETAIL=true
	}

	[ -n "$clean" ] || {
		cat "${MYXROOT:-/usr/local/share/myx.common}/include/remote/step3-remote-temp-setup.sh.include" \
		| if [ -z "$interactive " ] ; then
			RemoteContext --intern-no-comment-cat-for-script
		else
			RemoteContext --intern-one-liner-cat-for-script
		fi
		set +x
	}

	local lp rp entry

	printf '%b' "$includePaths" | awk '!seen[$0]++' \
	| awk -F: '{r=$2?$2:"."; a[$1]=(a[$1]?a[$1]" "r:r)}END{for(b in a)print b":"a[b]}' \
	| while IFS=: read -r basePath relPaths; do
		lp="${basePath}:{${relPaths}}"
		[ -z "$verbose" ] || echo "Local: 📦 pack: '$lp'" >&2
		echo 'echo "📦 Extracting: '$lp'..." >&2'

		# decode on receiver side
		echo '{ tr -d "\n" | {'
		echo ' { command -v openssl >/dev/null 2>&1 && {'
		[ -z "$MDSC_DETAIL" ] || \
		echo '    echo "ImageDeploy: 📦 base64: using \"openssl\" to decode" >&2'
		echo '    openssl base64 -d -A 2>/dev/null || openssl enc -base64 -d -A'
		echo ' } } || \'
		echo ' { command -v base64 >/dev/null 2>&1 && {'
		[ -z "$MDSC_DETAIL" ] || \
		echo '    echo "ImageDeploy: 📦 base64: using \"base64\" utility to decode" >&2'
		echo '    base64 --ignore-garbage -d 2>/dev/null || base64 -D'
		echo ' } } || \'
		echo ' { command -v uudecode >/dev/null 2>&1 && {'
		[ -z "$MDSC_DETAIL" ] || \
		echo '    echo "ImageDeploy: 📦 base64: using \"uudecode\" utility to decode" >&2'
		echo '    { printf "begin-base64 644 packed.b64\\n"; cat; printf "\\n====\\nend\\n"; } | uudecode -p'
		echo ' } } || \'
		echo ' { echo "⛔ ERROR: can not detect base64 encoder on target machine, make sure: \"openssl\", \"base64\" or \"uuencode\" utility is available" >&2; exit 1; }'
		echo "} | tar jxf - ; } <<'EOF_PROJECT_TAR_XXXXXXXX'"

		# watch out: $(echo intentionally splits into several arguments!
		# encode on sender side
		{ 
			tar -jcf - \
				--format=ustar \
				--exclude='.DS_Store' \
				--exclude='.AppleDouble' \
				--exclude='Icon?' \
				--exclude='._*' \
				--exclude='.Spotlight-V100' \
				--exclude='.Trashes' \
				--exclude='.git' \
				--exclude='.git/**' \
				--exclude='CVS' \
				$( if tar --version 2>/dev/null | grep -q GNU ; then
					echo --no-xattrs --no-acls --no-selinux
				fi ) \
				$( if tar --version 2>/dev/null | grep -qi bsdtar ; then 
					echo --disable-copyfile $( [ "$(uname)" != FreeBSD ] || echo --no-mac-metadata )
				fi ) \
				-C "$basePath/" $relPaths \
			| (
				{ command -v openssl	>/dev/null 2>&1 && {
					[ -z "$MDSC_DETAIL" ] || echo "$MDSC_CMD: 📦 base64: using \"openssl\" to encode base64" >&2
					openssl base64 -e -A 2>/dev/null || openssl enc -base64 -A
				} } || \
				{ command -v base64	>/dev/null 2>&1 && {
					[ -z "$MDSC_DETAIL" ] || echo "$MDSC_CMD: 📦 base64: using \"base64\" utility to encode" >&2
					base64 -w0
				} } || \
				{ command -v uuencode	>/dev/null 2>&1 && {
					[ -z "$MDSC_DETAIL" ] || echo "$MDSC_CMD: 📦 base64: using \"uuencode\" utility to encode" >&2
					uuencode -m packed.tbz | sed "1d; /^====\$/d"
				} } || \
				{
					echo "$MDSC_CMD: ⛔ ERROR: can not detect base64 encoder, make sure: \"openssl\", \"base64\" or \"uuencode\" utility is available" >&2
					set +e ; return 1
				}
			)
		} | fold -w320

		sleep .01

		printf '\nEOF_PROJECT_TAR_XXXXXXXX\n'
		# remote script will continue after this

	done

	printf '%b' "$includeScripts" | awk '!seen[$0]++' | while IFS= read -r entry; do
		[ -z "$verbose" ] || printf '%s\n' "Local: 📦 pack: embedding '$entry'" >&2

		echo
		echo "echo '📦 Running: $( basename "$entry" )...' >&2"
		cat "$entry"

		# If this is a mixin.include, and $interactive is non-empty,
		# look for the corresponding -interactive.mixin.sh.include file
		case $entry in
			*-mixin.base.sh.include)
				if [ -n "$interactive" ]; then
					entry="${entry%-mixin.base.sh.include}-mixin.interactive.sh.include"
					[ -z "${verbose:1}" ] || printf '%s\n' "Local: 📦 pack: looking for interactive add-on at '$entry'" >&2
					if [ -n "$interactive" ] && [ -f "$entry" ]; then
						[ -z "$verbose" ] || printf '%s\n' "Local: 📦 pack: embedding interactive mixin '$entry'" >&2
						echo "echo '📦 Running: $( basename "$entry" )...' >&2"
						cat "$entry"
					fi
				fi
			;;
		esac

		echo
	done

	[ -z "$includeCommands" ] || {
		[ -z "$verbose" ] || echo "Local: 📦 pack: embedding commands" >&2
		echo "echo '📦 Running: extra commands...' >&2"
		printf '\n%b\n' "$includeCommands"
	}

	[ -z "$interactive" ] || {

		echo "export TERM=${TERM:-xterm-256color}"

		{ 
			cat "$templateRoot/step4-interactive-suffix.sh.include" 
		} | RemoteContext --intern-no-comment-cat-for-script

		printf '\n#END-NON-INTERACTIVE#\n'

		#awk 'BEGIN { for(i=1;i<=8192;i++)printf"#\010"; }' # purge shell's buffer
		echo 'echo "Remote: ↪ interactive shell activate..." >&2'
		
		echo 'exec bash --noprofile --rcfile "$IMAGE_UNPACK_DIR/console.rc" -i'
		#echo 'exec bash --noprofile --rcfile "$IMAGE_UNPACK_DIR/console.rc" -i < /dev/tty > /dev/tty 2>&1'
		#echo 'exec script -q /dev/null bash --noprofile --rcfile "$IMAGE_UNPACK_DIR/console.rc" -i'

		if [ -z "$force" ] || [[ ! -t 1 ]]; then
			set -e
			if true; then
				trap "stty \"$(stty -g)\"" EXIT; stty raw; cat ; exit 0
			elif command -v stdbuf >/dev/null; then
				echo 'Attaching tty (stdbuf)...' >&2
				exec stdbuf -o0 bash -c 'trap "stty \"$(stty -g)\"" EXIT; stty raw; cat'
			elif command -v script >/dev/null; then
				echo 'Attaching tty (script)...' >&2
				exec script -q /dev/null bash -c 'trap "stty \"$(stty -g)\"" EXIT; stty raw; cat'
			else
				echo 'Attaching tty (cat)...' >&2
				exec bash -c 'trap "stty \"$(stty -g)\"" EXIT; stty raw; cat'
			fi
			exit 1 
		fi
		exit 0
	}
}

case "$0" in
	*/myx.common/bin/lib/remoteContext)
		if [ -z "$1" ] || [ "$1" == '--help' ] ; then
			RemoteContext ${1:-"--help-syntax"}
			exit 1
		fi
		set -e
		RemoteContext "$@"
	;;
esac

